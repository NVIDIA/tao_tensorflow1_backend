// Copyright (c) 2018-2019, NVIDIA CORPORATION.  All rights reserved.
#undef EIGEN_USE_GPU
#include <float.h>

// Include common code.
#include "generate_lineseg_from_polygon.h"

// We should register only once (CPU).
REGISTER_OP("GenerateLinesegFromPolygon")
    .Input("width: int32")
    .Input("height: int32")
    .Input("polygon_vertices: float")
    .Input("vertex_counts_per_polygon: int32")
    .Input("class_ids_per_polygon: int32")
    .Input("polygons_per_image: int32")
    .Input("is_polyline_per_polygon: bool")
    .Output("linesegments_per_image: int32")
    .Output("linesegments: float")
    .Output("cluster_count_per_image: int32")
    .Attr("skip_conversion_class_mask: int = 0")
    .Attr("scanline_conversion_class_mask: int = 0")
    .Attr("verbose: bool = false")
    .SetShapeFn([](::shape_inference::InferenceContext* c) {
        // Inherit the output shape from the attributes.
        std::vector<::shape_inference::DimensionHandle> dims_out1;
        dims_out1.push_back(c->UnknownDim());  // Number of images. like batch size.
        c->set_output(0, c->MakeShape(dims_out1));

        std::vector<::shape_inference::DimensionHandle> dims_out2;
        dims_out2.push_back(c->UnknownDim());
        dims_out2.push_back(c->UnknownDim());  // Number of all line segments in the all.
        c->set_output(1, c->MakeShape(dims_out2));

        c->set_output(2, c->MakeShape(dims_out1));
        return Status::OK();
    })
    .Doc(R"doc(
        Generate Linesegment From Polygon Operator.
        Summary:
            For each image label, provided information like image dimension (width and height),
            a set of points ([x,y] vertices, polygon_vertices, ordered in some orientation),
            number of points associated for each polygon (vertex_counts_per_polygon),
            number of polygons vetices of all polygons in this image, class id/attributes associated
            with each polygon in this image, number of polygons in each images (polygons_per_image),
            this operator will provide the extracted line segments inside each polygon,
            which are generated by finding the normal vectors from each line segments that form
            the original polygons, then finding the intersections of each other polygons with the
            normal vectors, then finding the middle points to form new center line segments that
            are inside the (middle part) polygons.

            Along with line segments, original class id and polygon id (cluster id) from the original polygon
            data will be also provided. This operator will also provide angles information that are calculated
            for the top and bottom point that form each line segment, and angle value that is averaged
            from the adjacent line segments.

            This operator also detects v-shape polygons based on geometry information such as number of
            turns, length of each path, and angles of each path. Then it splits the v-shape polygon into two
            straight polygons.

        References:
            [1] https://confluence.nvidia.com/display/AV/Line+Regressor+Encoding

        Arguments:
            width: input image width, it a tensor of flat list with each element
                represents image width for each image in that batch.
            height: input image height, similar as above for height.
            polygon_vertices: a tensor in the form of a list of lists. The top-level list contains
                sub-lists with 2 elements each; each sub-list contains absolute [x,y] coordinates
                of a single vertex of a single polygon for a single image. The length of the top-level
                list is therefore equal to the total number of vertices over all polygons
                that drawn over all raster maps.
            vertex_counts_per_polygon: a tensor in the form of a flat list. The elements of the list
                are the vertex counts for each polygon. Thus, the length of this list is equal
                to the number of polygons. If one to sum all the values in this list, the sum
                should equal the length of the ``polygon_vertices`` list above.
            class_ids_per_polygon: a tensor in the form of a flat list having the same shape as the
                ``vertex_counts_per_polygon`` list above. Each list element is an ID representing
                the class to which each polygon belongs.
            polygons_per_image: if `None` (the default), assume only one single image (i.e. this
                call will output only a single raster map). Otherwise, this should be a tensor in
                the form of a flat list, where each list element is the number of polygons to be
                drawn for that image (raster). In this case, the sum of the list values should equal
                the length of the ``vertex_counts_per_polygon`` list above.
            is_polyline_per_polygon: a bool tensor in the form of a flat list having the same shape as the
                ``vertex_counts_per_polygon`` list above. Each list element is a bool value (true/false)
                representing if the polygon is actually a polyline (true) or not (false).
                Being a polyline means the vertices are in the lane line rather than surrounding
                the lane marker. Being a polyline means the vertices are in the lane line rather than
                surrounding the lane marker.

        Attributes:
            skip_conversion_class_mask: set bit of class id that we want to skip center line segment
                                        conversion. For example, if we want to skip conversion for class
                                        id 2, 4, 8, then we set 2nd, 4th and 8th bit on to skip the
                                        conversion.
            verbose: if to print additional information.

        Returns:
            linesegments_per_image: a int32 tensor with shape (batch_size),
                                    where batch size = num of images in one batch. this tensor
                                    provides number of total line segments count for each
                                    image.
            linesegments: a fp32 tensor with shape (Number_total_lineseg, Number_channel_output)
                          where Number_total_lineseg total number of line segments in all
                          images, Number_channel_output=9, order of output are:
                          -0- top point x coordinate of this line segment
                          -1- top point y coordinate of this line segment
                          -2- bottom point x coordinate of this line segment
                          -3- bottom point y coordinate of this line segment
                          -4- angle (in radians) for this line segment
                          -5- angle (in radians) at top point of this line segment, averaged from
                              two adjacent line segments.
                          -6- angle (in radians) at bottom point of this line segment, averaged from
                              two adjacent line segments.
                          -7- class id associated this line segment
                          -8- cluster id associated this line segment
            cluster_count_per_image: a int32 tensor same shape as linesegments_per_image.
                                        This tensor provides number of total polygons in each image.
        )doc");

class GenerateLinesegFromPolygon : public _GenerateLinesegFromPolygon {
 public:
    explicit GenerateLinesegFromPolygon(OpKernelConstruction* context)
        : _GenerateLinesegFromPolygon(context) {}

    void Convert(OpKernelContext* context, const int nvertices, const int npolygons,
                 const int batch_size, const int len_class_ids_per_polygon,
                 const int* vertex_counts_per_polygon, const int* polygons_per_image,
                 const int* class_ids_per_polygon, const bool* is_polyline_per_polygon,
                 const float* input_polygon_vertices, const int* width_data, const int* height_data,
                 std::vector<Line2<float>>* line_segments,
                 std::vector<int>* line_segments_count_per_image,
                 std::vector<int>* cluster_count_per_image) {
        // Test that the sum of the `vertex_counts_per_polygon` vector adds up to
        // `nvertices`.
        int nvertices_from_vertex_counts = 0;
        for (int i = 0; i < npolygons; i++) {
            nvertices_from_vertex_counts += vertex_counts_per_polygon[i];
        }
        OP_REQUIRES(context, nvertices_from_vertex_counts == nvertices,
                    errors::InvalidArgument(
                        "Sum of vertex_counts_per_polygon", nvertices_from_vertex_counts,
                        " over all polygons does not add up to nvertices ", nvertices, "."));

        // Test that the sum of the `polygons_per_image` vector adds up to
        // `npolygons`.
        int npolygons_from_images = 0;
        for (int i = 0; i < batch_size; i++) {
            npolygons_from_images += polygons_per_image[i];
        }

        if (verbose_) {
            std::cout << " -----  num of polygons= " << npolygons << ", "
                      << "images=" << batch_size << std::endl;
        }
        OP_REQUIRES(
            context, npolygons_from_images == npolygons,
            errors::InvalidArgument("Sum of `polygons_from_images` over all images does not ",
                                    "add up to `npolygons`"));

        // max class id.
        int max_class_id = -1;

        // image > polygon > vertex.
        std::vector<std::vector<Polygon2f>> vector_of_polygon_vector;

        // read data from tensorflow op.
        // global indices.
        size_t p = 0;  // polygon.
        size_t c = 0;  // vertex coordinate.

        (*cluster_count_per_image) = std::vector<int>(batch_size, 0);
        (*line_segments_count_per_image) = std::vector<int>(batch_size, 0);
        (*line_segments).clear();
        // for each image.
        for (size_t i = 0; i < (size_t)batch_size; i++) {
            int width = width_data[i];
            int height = height_data[i];

            // for each polygon in the image.
            // cluster id needs to start counting from one.
            int cluster_id = 1;
            int total_counts_per_image = 0;
            for (int local_p = 0; local_p < polygons_per_image[i]; local_p++, p++) {
                // class id.
                const int class_id = class_ids_per_polygon[p];
                const bool is_polyline = is_polyline_per_polygon[p];

                if (class_id >= 0) {
                    // check bit if we want to skip center line conversion.
                    uint32_t bitcheck = 1 << class_id;
                    bool skip_centerline_conversion = false;
                    if (bitcheck & skip_conversion_class_mask_) {
                        skip_centerline_conversion = true;
                    }
                    bool extract_via_horizontal_scanline = false;
                    if (bitcheck & scanline_conversion_class_mask_) {
                        extract_via_horizontal_scanline = true;
                    }
                    if (class_id > max_class_id) {
                        max_class_id = class_id;
                    }

                    // new polygon.
                    Polygon2f polygon;

                    // set class ID and attribute.
                    polygon.set_class_id(class_id);
                    polygon.set_is_polyline(is_polyline);
                    polygon.set_dimension(width, height);
                    polygon.set_extract_via_horizontal_scanline(extract_via_horizontal_scanline);

                    // for each vertex in the polygon.
                    for (int local_v = 0; local_v < vertex_counts_per_polygon[p]; local_v++) {
                        // read coordinates.
                        const float x = input_polygon_vertices[c++];
                        const float y = input_polygon_vertices[c++];
                        // add vertex.
                        polygon.add_vertex(x, y);
                    }

                    bool flag_standard_process = false;
                    if (skip_centerline_conversion == false) {
                        // For certain class we will skip conversion.
                        if (is_polyline == false) {
                            // Decide whether it is a polygon or a polyline.
                            if (FIX_V_SHAPE_POLYGON && polygon.is_v_shape_polygon()) {
                                // Detect V shape polygon.
                                Polygon2f polygon1;
                                Polygon2f polygon2;

                                polygon1.set_class_id(class_id);
                                polygon1.set_dimension(width, height);
                                polygon1.set_is_polyline(false);
                                polygon1.set_extract_via_horizontal_scanline(
                                    extract_via_horizontal_scanline);

                                polygon2.set_class_id(class_id);
                                polygon2.set_dimension(width, height);
                                polygon2.set_is_polyline(false);
                                polygon2.set_extract_via_horizontal_scanline(
                                    extract_via_horizontal_scanline);

                                // Get V shape vertices (which indicate where to split the polygon).
                                std::vector<Point2<float>> v_shape_vertices =
                                    polygon.get_v_shape_vertices();

                                // Move back to the start and go over vertices again.
                                c -= vertex_counts_per_polygon[p] * 2;
                                int count = 0;
                                for (int local_v = 0; local_v < vertex_counts_per_polygon[p];
                                     local_v++) {
                                    // Read coordinates.
                                    const float x = input_polygon_vertices[c++];
                                    const float y = input_polygon_vertices[c++];

                                    if ((x == v_shape_vertices[0].x &&
                                         y == v_shape_vertices[0].y) ||
                                        (x == v_shape_vertices[1].x &&
                                         y == v_shape_vertices[1].y)) {
                                        count++;
                                        // Add shared vertex to both polygons.
                                        if (count % 2 == 0) {
                                            polygon2.add_vertex(x, y);
                                        } else {
                                            polygon1.add_vertex(x, y);
                                        }
                                    }
                                    // Assign vertices to two polygons.
                                    if (count % 2 == 0) {
                                        polygon1.add_vertex(x, y);
                                    } else {
                                        polygon2.add_vertex(x, y);
                                    }
                                }
                                // Extract centerlines for polygon1.
                                if (polygon1.extract_centerlines(cluster_id)) {
                                    std::vector<Line2<float>> line_data =
                                        polygon1.get_centerlines();
                                    (*line_segments)
                                        .insert((*line_segments).end(), line_data.begin(),
                                                line_data.end());
                                    total_counts_per_image += line_data.size();
                                    cluster_id++;
                                }
                                // Extract centerlines for polygon2.
                                if (polygon2.extract_centerlines(cluster_id)) {
                                    std::vector<Line2<float>> line_data =
                                        polygon2.get_centerlines();
                                    (*line_segments)
                                        .insert((*line_segments).end(), line_data.begin(),
                                                line_data.end());
                                    total_counts_per_image += line_data.size();
                                    cluster_id++;
                                }
                                flag_standard_process = false;
                            } else {
                                // Extract the center line for the entire polygon.
                                flag_standard_process = polygon.extract_centerlines(cluster_id);
                            }
                        } else {
                            // Skip extracting the center line, but still keeps angles.
                            flag_standard_process = polygon.skip_extract_centerlines(cluster_id);
                        }
                    } else {
                        // At least convert it to linesegments.
                        // below is to keep polygon.
                        flag_standard_process =
                            polygon.skip_conversion_to_polygon_process(cluster_id);
                    }

                    if (flag_standard_process) {
                        std::vector<Line2<float>> line_data = polygon.get_centerlines();
                        (*line_segments)
                            .insert((*line_segments).end(), line_data.begin(), line_data.end());
                        total_counts_per_image += line_data.size();
                        cluster_id++;
                    }

                } else {
                    // Do nothing but increasing c.
                    c += 2 * vertex_counts_per_polygon[p];
                }
            }
            (*line_segments_count_per_image)[i] = total_counts_per_image;
            (*cluster_count_per_image)[i] =
                cluster_id - 1;  // get number of clusters, minus 1 to get the count.
        }
        if (verbose_) {
            std::cout << " ----  Done  ---- " << std::endl;
        }
    }
};

#pragma message("Registering CPU kernel")
REGISTER_KERNEL_BUILDER(Name("GenerateLinesegFromPolygon")
                            .Device(DEVICE_CPU)
                            .HostMemory("width")
                            .HostMemory("height")
                            .HostMemory("polygon_vertices")
                            .HostMemory("vertex_counts_per_polygon")
                            .HostMemory("class_ids_per_polygon")
                            .HostMemory("is_polyline_per_polygon")
                            .HostMemory("polygons_per_image"),
                        GenerateLinesegFromPolygon);
